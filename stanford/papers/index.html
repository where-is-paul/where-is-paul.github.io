
<!DOCTYPE html>
<html class="no-js" lang="en-US">
<head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="description" content="">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="keywords" content="paul liu ubc stanford research algorithms computer science">

 
<meta property="og:type" content="article"/>
<meta property="og:description" content=""/>
<meta property="og:title" content="Papers"/>
<meta property="og:site_name" content="The webpage of Paul Liu"/>
<meta property="og:image" content="" />
<meta property="og:image:type" content="image/jpeg" />
<meta property="og:image:width" content="" />
<meta property="og:image:height" content="" />
<meta property="og:url" content="https://cs.stanford.edu/people/paulliu/papers/">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-01"/>
<meta property="article:modified_time" content="2022-04-01"/>

    <base href="https://cs.stanford.edu/people/paulliu/">
    <title> Papers </title>
    <link rel="canonical" href="https://cs.stanford.edu/people/paulliu/papers/">
    <link href="https://cs.stanford.edu/people/paulliu/papers/index.xml" rel="alternate" type="application/rss+xml" title="Papers" />

    <link href='https://fonts.googleapis.com/css?family=Fjalla+One|Open+Sans:300' rel='stylesheet' type='text/css'>

<link rel="stylesheet" href="https://cs.stanford.edu/people/paulliu/css/ZGS.min.83febcc2d7f02955d1d4aea87901a5d435b0ae969228951dd94ce87a4a217a94.css">
    <link rel="shortcut icon" href="https://cs.stanford.edu/people/paulliu/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="https://cs.stanford.edu/people/paulliu/apple-touch-icon.png" />
</head>

<body lang="en">

<header id="header">
    <figure>
      <a href="https://cs.stanford.edu/people/paulliu" border=0 id="logolink"><div class="icon-paul" id="logo"> </div></a>
    </figure>
    <nav id="nav">
    

<ul id="mainnav">
    <li>
        <a href="https://cs.stanford.edu/people/paulliu/papers">
        <span class="icon"> <i aria-hidden="true" class="icon-pencil"></i></span>
        <span> papers </span>
    </a>
    </li>
    <li>
    <a href="https://cs.stanford.edu/people/paulliu/projects">
        <span class="icon"> <i aria-hidden="true" class="icon-code"></i></span>
        <span> projects </span>
    </a>
    </li>
    <li>
    <a href="https://cs.stanford.edu/people/paulliu/fun-stuff">
        <span class="icon"> <i aria-hidden="true" class="icon-pacman"></i></span>
        <span> fun stuff </span>
    </a>
    </li>
</ul>

    
<div class="social">
    <a href="https://www.linkedin.com/in/where-is-paul/" class="linkedin" title="LinkedIn"><span class="icon icon-linkedin"></span></a>
    <a href="https://github.com/where-is-paul/" title="GitHub" class="github"><span class="icon icon-github"></span></a>
    <a href="https://scholar.google.com/citations?user=3ct054AAAAAJ&hl=en" title="Scholar" class="scholar"><span class="icon icon-scholar"></span></a>
    <a href="https://cs.stanford.edu/people/paulliu/files/webcv.pdf" title="CV" class="cv"><span class="icon icon-resume"></span></a>
</div>
    </nav>
</header>


<section id="main">
  <div>
   <h1 id="title">Papers</h1>
            
            <h2>2022</h2>
                <ul id="list">
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">MonoTrack: Shuttle trajectory reconstruction from monocular badminton video</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> CVSports@CVPR 2022</div>
</summary>

<div class="medium">
Paul Liu and Jui-Hsien Wang
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/cvpr-2022.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/cvpr-2022.png">
            </a>
        
    </figure>
    

<p>
Trajectory estimation is a fundamental component of racket sport analytics, as the trajectory contains information not only about the winning and losing of each point, but also how it was won or lost. In sports such as badminton, players benefit from knowing the full 3D trajectory, as the height of shuttlecock or ball provides valuable tactical information. Unfortunately, 3D reconstruction is a notoriously hard problem, and standard trajectory estimators can only track 2D pixel coordinates. In this work, we present the first complete end-to-end system for the extraction and segmentation of 3D shuttle trajectories from monocular badminton videos. Our system integrates badminton domain knowledge such as court dimension, shot placement, physical laws of motion, along with vision-based features such as player poses and shuttle tracking. We find that significant engineering efforts and model improvements are needed to make the overall system robust, and as a by-product of our work, improve state-of-the-art results on court recognition, 2D trajectory estimation, and hit recognition.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/badminton">badminton</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/computer-vision">computer vision</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/machine-learning">machine learning</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/cvpr-2022.pdf">[pdf]</a>







</details>
</li>
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Streaming Submodular Maximization under Matroid Constraints</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> ICALP 2022</div>
</summary>

<div class="medium">
Moran Feldman, Paul Liu, Ashkan Norouzi-Fard, Ola Svensson, Jan Vondrák, and Rico Zenklusen
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

<p>
Recent progress in  (semi-)streaming algorithms for monotone submodular function maximization has led to tight results for a simple  cardinality constraint. However,  current techniques fail to give a similar understanding for natural generalizations, including matroid constraints. Our paper improves on the previously best approximation guarantees of $1/4$ and $1/2$ for single-pass and multi-pass streaming algorithms, respectively. In fact, our multi-pass streaming algorithm is tight in that any algorithm with a better guarantee than $1/2$ must make several passes through the stream and any algorithm that beats our guarantee of $1-1/e$ must make linearly many passes (as well as an exponential number of value oracle queries). 
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/submodular-optimization">submodular optimization</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/streaming">streaming</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/random-order">random order</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/multipass">multipass</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/icalp-2022.pdf">[pdf]</a>







</details>
</li>
                    
                </ul>
            
            <h2>2021</h2>
                <ul id="list">
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Cardinality constrained submodular maximization for random streams</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> NeurIPS 2021</div>
</summary>

<div class="medium">
Paul Liu, Aviad Rubinstein, Jan Vondrák, Junyao Zhao
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/neurips-2021.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/neurips-21.png">
            </a>
        
    </figure>
    

<p>
We consider the problem of maximizing submodular functions in single-pass streaming and secretaries-with-shortlists models, both with random arrival order. For cardinality constrained monotone functions, Agrawal, Shadravan, and Stein gave a single-pass $(1-1/e-\varepsilon)$-approximation algorithm using only linear memory, but their exponential dependence on $\varepsilon$ makes it impractical even for $\varepsilon=0.1$. We simplify both the algorithm and the analysis, obtaining an exponential improvement in the $\varepsilon$-dependence (in particular, $O(k/\varepsilon)$ memory). Extending these techniques, we also give a simple $(1/e-\varepsilon)$-approximation for non-monotone functions in $O(k/\varepsilon)$ memory. For the monotone case, we also give a corresponding unconditional hardness barrier of $1-1/e+\varepsilon$ for single-pass algorithms in randomly ordered streams, even assuming unlimited computation.</p><p>Finally, we show that the algorithms are simple to implement and work well on real world datasets.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/streaming">streaming</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/random-order">random order</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/submodular">submodular</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/neurips-2021.pdf">[pdf]</a>


<a href="https://github.com/where-is-paul/submodular-streaming" style="color:indigo">[code]</a>



<a href="https://cs.stanford.edu/people/paulliu/files/neurips-2021-poster.pdf" style="color:violet">[poster]</a>


<a href="https://cs.stanford.edu/people/paulliu/files/neurips-2021-slides.pdf" style="color:orange">[slides]</a>



</details>
</li>
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Improving Query Categorization with Categorical Graph Neural Networks</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> BigData (Industry) 2021</div>
</summary>

<div class="medium">
Tianchuan Du, Keng-Hao Chang, Paul Liu, Ruofei Zhang
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/bigdata-2021.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/bigdata-2021.png">
            </a>
        
    </figure>
    

<p>
We propose a class of graph-based network structures, which we call Categorical Graph Neural Networks (CaGNN). Over a query categorization dataset of 2k categories and another ad title categorization dataset of 5k categories, CaGNN improves performance significantly compared to a baseline Deep Neural Network model without the CaGNN structure. Notably, top 3 prediction recall increases from 90.15% to 91.40% for the ad title categorization task, for which is quite significant at over 90% level for more than 5k categories. By inspecting the learned category embeddings and the flow of message passing, we show that CaGNN effectively encapsulates useful graph structural information. Online A/B testing result shows that an ad ranking model with CaGNN-based features has increased ad click-through rate by 1.81% and reduced defect rate by 2.64%. The model has been deployed to production.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/graph-neural-networks">graph neural networks</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/machine-learning">machine learning</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/bigdata-2021.pdf">[pdf]</a>







</details>
</li>
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Coordinated Motion Planning Through Randomized k-Opt</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> ACM JEA, SoCG 2021</div>
</summary>

<div class="medium">
Jack Spalding-Jamieson, Paul Liu, Brandon Zhang, Da Wei Zheng
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/socg-2021.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/socg-2021.png">
            </a>
        
    </figure>
    

<p>
This paper describes the heuristics and algorithms used by team <b>gitastrophe</b> in the CG:SHOP 2021 Competition. The contest was run in two categories with different optimization objectives: SUM and MAX. Team gitastrophe placed <b>first</b> overall in the SUM category, <b>third</b> overall in the MAX category, and <b>first</b> among junior teams for both categories.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/computational-geometry">computational geometry</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/motion-planning">motion planning</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/socg-2021.pdf">[pdf]</a>


<a href="https://gitlab.com/jacketsj/cgshop2021" style="color:indigo">[code]</a>






</details>
</li>
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Elo-MMR: A Rating System for Massive Multiplayer Competitions</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> WWW 2021</div>
</summary>

<div class="medium">
Aram Ebtekar and Paul Liu
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/www-2021-elor.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/www-2021-elor.png">
            </a>
        
    </figure>
    

<p>
Skill estimation mechanisms, colloquially known as rating systems, play an important role in competitive sports and games. They provide a measure of player skill, which incentivizes competitive performances and enables balanced match-ups. In this paper, we present a novel Bayesian rating system for contests with many participants. It is widely applicable to competition formats with discrete ranked matches, such as online programming competitions, obstacle courses races, and video games. The system's simplicity allows us to prove theoretical bounds on its robustness and runtime. In addition, we show that it is <b>incentive-compatible</b>: a player who seeks to maximize their rating will never want to underperform. Experimentally, the rating system surpasses existing systems in prediction accuracy, and computes faster than existing systems by up to an order of magnitude.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/big-data">big data</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/bayesian-systems">bayesian systems</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/www-2021-elor.pdf">[pdf]</a>


<a href="https://github.com/EbTech/Elo-MMR" style="color:indigo">[code]</a>


<a href="https://github.com/EbTech/Elo-MMR" style="color:brown">[data]</a>





</details>
</li>
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Diversity on the Go! Streaming Determinantal Point Processes under a Maximum Induced Cardinality Objective</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> WWW 2021</div>
</summary>

<div class="medium">
Paul Liu, Akshay Soni, Eun Yong Kang, Yajun Wang, Mehul Parsana
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/www-2021-mic.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/www-2021-mic.png">
            </a>
        
    </figure>
    

<p>
Over the past decade, Determinantal Point Processes (DPPs) have proven to be a mathematically elegant framework for modeling diversity. Given a set of items $N$, DPPs define a probability distribution over subsets of $N$, with sets of larger diversity having greater probability. Recently, DPPs have achieved success in the domain of recommendation systems, as a method to enforce diversity of recommendations in addition to relevance.</p><p>In large-scale recommendation applications however, the input typically comes in the form of a stream too large to fit into main memory. However, the natural greedy algorithm for DPP-based recommendations is memory intensive, and cannot be used in a streaming setting.</p><p>In this work, we give the first streaming algorithm for optimizing DPPs under the Maximum Induced Cardinality (MIC) objective of Gillenwater et al. As noted by Gillenwater et al., the MIC objective is better suited towards recommendation systems than the classically used maximum a posteriori (MAP) DPP objective. In the insertion-only streaming model, our algorithm runs in $\tilde{O}(k^2)$ time per update and uses $\tilde{O}(k)$ memory, where $k$ is the number of diverse items to be selected. In the sliding window streaming model, our algorithm runs in $\tilde{O}(\sqrt{n}k^2)$ time per update and $\tilde{O}(\sqrt{n}k)$ memory where $n$ is the size of the sliding window. The approximation guarantees are simple, and depend on the largest and the $k$-th largest eigenvalues of the kernel matrix used to model diversity. We show that in practice, the algorithm often achieves close to optimal results, and meets the memory and latency requirements of production systems. Furthermore, the algorithm works well even in a non-streaming setting, and runs in a fraction of time compared to the classic greedy algorithm.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/streaming">streaming</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/determinantal-point-process">determinantal point process</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/www-2021-mic.pdf">[pdf]</a>


<a href="https://gitlab.com/paul.liu.ubc/streaming-mic-dpp" style="color:indigo">[code]</a>






</details>
</li>
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Improved Algorithms for Edge Colouring in the W-Streaming Model</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> SOSA@SODA 2021</div>
</summary>

<div class="medium">
Paul Liu and Moses Charikar
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

<p>
In the W-streaming model, an algorithm is given $O(n \text{polylog} n)$ space and must process a large graph of up to $O(n^2)$ edges. In this short note we give two algorithms for edge colouring under the W-streaming model. For edge colouring in W-streaming, a colour for every edge must be determined by the time all the edges are streamed. Our first algorithm uses $\Delta+o(\Delta)$ colours in $O(n \log^2 n)$ space when the edges arrive according to a uniformly random permutation. The second algorithm uses $(1+o(1))\Delta^2/s$ colours in $\tilde{O}(ns)$ space when edges arrival adversarially.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/graph-algorithms">graph algorithms</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/streaming">streaming</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/colouring">colouring</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/sosa-2021.pdf">[pdf]</a>





<a href="https://cs.stanford.edu/people/paulliu/files/sosa-2021-slides.pdf" style="color:orange">[slides]</a>


<a href="https://player.vimeo.com/video/497237518" style="color:green" target="_blank">[video]</a>


</details>
</li>
                    
                </ul>
            
            <h2>2020</h2>
                <ul id="list">
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Retrieving Top Weighted Triangles in Graphs</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> WSDM, SIAMNS 2020</div>
</summary>

<div class="medium">
Raunak Kumar*, Paul Liu*, Moses Charikar, Austin Benson
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/wsdm2020.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/topk.png">
            </a>
        
    </figure>
    

<p>
Pattern counting in graphs is a fundamental primitive for many network analysis tasks, and a number of methods have been developed for scaling subgraph counting to large graphs. Many real-world networks carry a natural notion of strength of connection between nodes, which are often modeled by a weighted graph, but existing scalable graph algorithms for pattern mining are designed for unweighted graphs. Here, we develop a suite of deterministic and random sampling algorithms that enable the fast discovery of the 3- cliques (triangles) with the largest weight in a graph, where weight is measured by a generalized mean of a triangle’s edges. For example, one of our proposed algorithms can find the top-1000 weighted triangles of a weighted graph with billions of edges in thirty seconds on a commodity server, which is orders of magnitude faster than existing “fast” enumeration schemes. Our methods thus open the door towards scalable pattern mining in weighted graphs.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/graph-algorithms">graph algorithms</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/big-data">big data</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/wsdm2020.pdf">[pdf]</a>


<a href="https://github.com/raunakkmr/Retrieving-top-weighted-triangles-in-graphs" style="color:indigo">[code]</a>



<a href="https://cs.stanford.edu/people/paulliu/files/wsdm2020-poster.pdf" style="color:violet">[poster]</a>


<a href="https://cs.stanford.edu/people/paulliu/files/wsdm2020-slides.pdf" style="color:orange">[slides]</a>



</details>
</li>
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">A Polynomial Lower Bound on Adaptive Complexity of Submodular Maximization</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> STOC 2020</div>
</summary>

<div class="medium">
Wenzheng Li, Paul Liu, Jan Vondrák
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/stoc-2020.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/stoc-2020.png">
            </a>
        
    </figure>
    

<p>
Informally, the adaptive model measures complexity by the longest chain of sequentially dependent calls to $f$ in the algorithm. The focus of the adaptive model is to reward highly parallel algorithms, and penalize algorithms that have high 'sequentiality'. Much work has been devoted recently to creating efficient algorithms for submodular optimization (SUBMOD) in the adaptive model. We focus instead on the lower bound, and provide the first lower bound showing that any approximation for monotone SUBMOD takes polynomially many rounds as the approximation factor approaches $1-1/e$.</p><p>For the unconstrained non-monotone maximization problem, we show a positive result. For every instance, and every $\delta> 0$, either we obtain a $(1/2-\delta)$-approximation in 1 round, or a $(1/2 + \Omega(\delta^2))$-approximation in $O(1/\delta^2)$ rounds. Unlike the cardinality-constrained case, there cannot be an instance where (i) it is impossible to achieve an approximation factor better than $1/2$ regardless of the number of rounds, and (ii) it takes $r$ rounds to achieve a factor of $1/2 − O(1/r)$.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/submodular-optimization">submodular optimization</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/adaptive-model">adaptive model</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/stoc-2020.pdf">[pdf]</a>





<a href="https://cs.stanford.edu/people/paulliu/files/stoc-2020-slides.pdf" style="color:orange">[slides]</a>


<a href="https://www.youtube.com/watch?v=rXc2a36OznU" style="color:green" target="_blank">[video]</a>


</details>
</li>
                    
                </ul>
            
            <h2>2019</h2>
                <ul id="list">
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Submodular Optimization in the MapReduce Model</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> SOSA@SODA 2019</div>
</summary>

<div class="medium">
Paul Liu and Jan Vondrák
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/sosa-2019.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/sosa-2019.png">
            </a>
        
    </figure>
    

<p>
Submodular optimization has received significant attention in both practice and theory, as a wide array of problems in machine learning, auction theory, and combinatorial optimization have submodular structure. In practice, these problems often involve large amounts of data, and must be solved in a distributed way. One popular framework for running such distributed algorithms is MapReduce. In this paper, we present two simple algorithms for cardinality constrained submodular optimization in the MapReduce model: the first is a $(1/2 - o(1))$-approximation in 2 MapReduce rounds, and the second is a $(1 - 1/e - \epsilon)$-approximation in $\frac{1+o(1)}{\epsilon}$ MapReduce rounds.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/submodular-optimization">submodular optimization</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/mapreduce">mapreduce</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/sosa-2019.pdf">[pdf]</a>







</details>
</li>
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Sampling Methods for Counting Temporal Motifs</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> WSDM 2019</div>
</summary>

<div class="medium">
Paul Liu, Austin Benson, Moses Charikar
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/wsdm2019.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/wsdm-2019.png">
            </a>
        
    </figure>
    

<p>
Subgraph isomorphism is a classic and well studied problem in computer science. However, modern graph datasets now contain richer structure, and incorporating temporal information in particular has become a key part of network analysis. In this work we develop fast sampling algorithms for temporal motif counting (subgraph isomorphism where the subgraph must have edges appearing in a specific order). Our results show that we can achieve one to two orders of magnitude speedup over existing algorithms with minimal and controllable loss in accuracy on a number of datasets.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/graph-algorithms">graph algorithms</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/big-data">big data</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/wsdm2019.pdf">[pdf]</a>


<a href="https://gitlab.com/paul.liu.ubc/sampling-temporal-motifs" style="color:indigo">[code]</a>



<a href="https://cs.stanford.edu/people/paulliu/files/wsdm2019-poster.pdf" style="color:violet">[poster]</a>


<a href="https://cs.stanford.edu/people/paulliu/files/wsdm2019-slides.pdf" style="color:orange">[slides]</a>



</details>
</li>
                    
                </ul>
            
            <h2>2018</h2>
                <ul id="list">
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Greedy and Local Ratio Algorithms in the MapReduce Model</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> SPAA 2018</div>
</summary>

<div class="medium">
Nicholas J. A. Harvey, Christopher Liaw, Paul Liu
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/spaa-2018.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/spaa-18.png">
            </a>
        
    </figure>
    

<p>
MapReduce has become the de facto standard model for designing distributed algorithms to process big data on a cluster. There has been considerable research on designing efficient MapReduce algorithms for clustering, graph optimization, and submodular optimization problems. We develop new techniques for designing greedy and local ratio algorithms in this setting. Our randomized local ratio technique gives 2-approximations for weighted vertex cover and weighted matching, and an $f$-approximation for weighted set cover, all in a constant number of MapReduce rounds. Our randomized greedy technique gives algorithms for maximal independent set, maximal clique, and a $(1+\epsilon)\log \Delta$-approximation for weighted set cover. We also give greedy algorithms for vertex colouring with $(1+o(1))\Delta$ colours and edge colouring with $(1+o(1))\Delta$ colours.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/local-ratio">local ratio</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/mapreduce">mapreduce</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/spaa-2018.pdf">[pdf]</a>





<a href="https://cs.stanford.edu/people/paulliu/files/spaa-2018-slides.pdf" style="color:orange">[slides]</a>



</details>
</li>
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Approximation Schemes for Covering and Packing in the Streaming Model</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> CCCG 2018</div>
</summary>

<div class="medium">
Christopher Liaw, Paul Liu, Robert Reiss
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/cccg-2018.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/cccg-18.png">
            </a>
        
    </figure>
    

<p>
Within the computational geometry (CG) community, the <b>shifting strategy</b> is a popular algorithmic paradigm for approximation algorithms. In this work we revisit the shifting strategy in the streaming model. Using the streaming-shifting strategy, we give low-memory approximation algorithms for classical CG problems such as unit disc cover. When combined with the shifting coreset technique of Fonseca et al., we are able to approximate streaming variants of geometric dominating set, independent set, etc.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/computational-geometry">computational geometry</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/streaming">streaming</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/cccg-2018.pdf">[pdf]</a>







</details>
</li>
                    
                </ul>
            
            <h2>2017</h2>
                <ul id="list">
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">SYM-ILDL: Incomplete $LDL^T$ Factorization of Symmetric Indefinite and Skew-Symmetric Matrices</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> ACM Trans. Math. Softw. 2017</div>
</summary>

<div class="medium">
Chen Greif, Paul Liu, Shiwen He
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/https://arxiv.org/pdf/1505.07589.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/matrix-coloured.png">
            </a>
        
    </figure>
    

<p>
SYM-ILDL is a numerical software package that computes incomplete $LDL^T$ (or `ILDL') factorizations of symmetric indefinite and real skew-symmetric matrices. The core of the algorithm is a Crout variant of incomplete LU (ILU), originally introduced and implemented for symmetric matrices by [Li and Saad, Crout versions of ILU factorization with pivoting for sparse symmetric matrices, Transactions on Numerical Analysis 20, pp. 75--85, 2005]. Our code is economical in terms of storage and it deals with real skew-symmetric matrices as well, in addition to symmetric ones. The package is written in C++ and it is templated, open source, and includes a MATLAB interface. The code includes built-in RCM and AMD reordering, two equilibration strategies, threshold Bunch-Kaufman pivoting and rook pivoting, as well as a wrapper to MC64, a popular matching based equilibration and reordering algorithm. We also include two built-in iterative solvers: SQMR preconditioned with ILDL, or MINRES preconditioned with a symmetric positive definite preconditioner based on the ILDL factorization.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/numerical-analysis">numerical analysis</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/https://arxiv.org/pdf/1505.07589.pdf">[pdf]</a>


<a href="https://github.com/where-is-paul/matrix-factor" style="color:indigo">[code]</a>






</details>
</li>
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Approximation Algorithms for the Unit Disk Cover Problem in 2D and 3D</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> CCCG 2015, Comput. Geom. 2017</div>
</summary>

<div class="medium">
Ahmad Biniaz, Paul Liu, Anil Maheshwari, Michiel Smid
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/cccg-2016-long.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/cccg-15.png">
            </a>
        
    </figure>
    

<p>
Given a set P of n points in the plane, we consider the problem of covering P with a minimum number of unit disks. This problem is known to be NP-hard. We present a simple 4-approximation algorithm for this problem which runs in $O(n \log n)$-time. We also show how to extend this algorithm to other metrics, and to three dimensions.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/computational-geometry">computational geometry</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/cccg-2016-long.pdf">[pdf]</a>







</details>
</li>
                    
                </ul>
            
            <h2>2016</h2>
                <ul id="list">
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">Characterizing Minimum-Length Coordinated Motions for Two Discs</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> CCCG 2016</div>
</summary>

<div class="medium">
David Kirkpatrick and Paul Liu
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/cccg-2016.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/cccg-16.png">
            </a>
        
    </figure>
    

<p>
We study the problem of planning coordinated motions for two disc robots in an otherwise obstacle-free plane. We give a characterization of collision-avoiding motions that minimize the total trace length of the disc centres, for all initial and final configurations of the robots. The individual traces are composed of at most six (straight or circular-arc) segments, and their total length can be expressed as a simple integral with a closed form solution depending only on the initial and final configuration of the robots.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/computational-geometry">computational geometry</a>
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/motion-planning">motion planning</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/cccg-2016.pdf">[pdf]</a>







</details>
</li>
                    
                </ul>
            
            <h2>2014</h2>
                <ul id="list">
                    
                        
<li>
<details> 
<summary style="outline: none; display: flex; align-items: baseline;">
<div style="flex: 0.75">A Fast 25/6-approximation for the Minimum Unit Disk Cover Problem</div>
<div class="meta right" style="flex: 0.25; margin-left: 0.5em; font-weight: 600"> arXiv 2014</div>
</summary>

<div class="medium">
Paul Liu, Daniel Lu
</div>
<hr style="border-top: 0px solid #8c8b8b;"/>

<div class="abstract">

    
    <figure class="thumbnail left" style="margin: 1em">
        
            <a href="https://cs.stanford.edu/people/paulliu/files/https://arxiv.org/pdf/1406.3838.pdf" style="all: revert">
                <img src="https://cs.stanford.edu/people/paulliu/img/25-6-disc-cover.png">
            </a>
        
    </figure>
    

<p>
My very first paper!</p><p>Given a point set in 2D, what is the minimum number of unit radius discs that covers all of the points? This is called the Unit Disk Cover (UDC) problem and has a wide variety of applications in facility location, motion planning, and image processing. Unfortunately, UDC is also NP-Hard.</p><p>In this work we present simple and practical $25/6$-approximation algorithms for UDC with runtime $O(n \log n)$ and space $O(n)$. This algorithm additionally extends to discs in any $\ell_p$ norm.
</p>
</div>

<ul id="tags-special">
  
    <a href="https://cs.stanford.edu/people/paulliu/tags/computational-geometry">computational geometry</a>
  
</ul>



<a href="https://cs.stanford.edu/people/paulliu/files/https://arxiv.org/pdf/1406.3838.pdf">[pdf]</a>







</details>
</li>
                    
                </ul>
            
  </div>
</section>

<aside id="meta"> </aside>
<footer>
  <div>
   
  </div>
</footer>
<script type="text/javascript">
(function(){var j=function(a,b){return window.getComputedStyle?getComputedStyle(a).getPropertyValue(b):a.currentStyle[b]};var k=function(a,b,c){if(a.addEventListener)a.addEventListener(b,c,false);else a.attachEvent('on'+b,c)};var l=function(a,b){for(key in b)if(b.hasOwnProperty(key))a[key]=b[key];return a};window.fitText=function(d,e,f){var g=l({'minFontSize':-1/0,'maxFontSize':1/0},f);var h=function(a){var b=e||1;var c=function(){a.style.fontSize=Math.max(Math.min(a.clientWidth/(b*10),parseFloat(g.maxFontSize)),parseFloat(g.minFontSize))+'px'};c();k(window,'resize',c)};if(d.length)for(var i=0;i<d.length;i++)h(d[i]);else h(d);return d}})();
fitText(document.getElementById('title'), 1)
</script>

<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</body>
</html>

