<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>sym-ildl: lilc_matrix&lt; el_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">sym-ildl
   &#160;<span id="projectnumber">1.2</span>
   </div>
   <div id="projectbrief">Incomplete LDL&#39; factorizations of indefinite symmetric and skew-symmetric matrices.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classlilc__matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lilc_matrix&lt; el_type &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A list-of-lists (LIL) matrix in column oriented format.  
 <a href="singletonlilc__matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lilc__matrix__declarations_8h_source.html">lilc_matrix_declarations.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lilc_matrix&lt; el_type &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="singletonlilc__matrix.png" usemap="#lilc_matrix&lt; el_type &gt;_map" alt=""/>
  <map id="lilc_matrix&lt; el_type &gt;_map" name="lilc_matrix&lt; el_type &gt;_map">
<area href="classlil__sparse__matrix.html" title="The abstract parent of all sparse matrices. " alt="lil_sparse_matrix&lt; el_type &gt;" shape="rect" coords="0,0,171,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlilc__matrix_1_1pivot__type.html">pivot_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a83c70482c28275881562ee3937b5f591"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83c70482c28275881562ee3937b5f591"></a>
typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a><br class="typebreak" />
&lt; el_type &gt;::idx_vector_type&#160;</td><td class="memItemRight" valign="bottom"><b>idx_vector_type</b></td></tr>
<tr class="separator:a83c70482c28275881562ee3937b5f591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a7b6e31a6c9ebf2ea3a898fe646af6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5a7b6e31a6c9ebf2ea3a898fe646af6"></a>
typedef <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix</a><br class="typebreak" />
&lt; el_type &gt;::elt_vector_type&#160;</td><td class="memItemRight" valign="bottom"><b>elt_vector_type</b></td></tr>
<tr class="separator:aa5a7b6e31a6c9ebf2ea3a898fe646af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd399b5bc0ef50dcf5a59a671e32248"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cd399b5bc0ef50dcf5a59a671e32248"></a>
typedef idx_vector_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>idx_it</b></td></tr>
<tr class="separator:a8cd399b5bc0ef50dcf5a59a671e32248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34c37b7095e283a7e5d7160fe26fd1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad34c37b7095e283a7e5d7160fe26fd1b"></a>
typedef elt_vector_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>elt_it</b></td></tr>
<tr class="separator:ad34c37b7095e283a7e5d7160fe26fd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classlil__sparse__matrix"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classlil__sparse__matrix')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix&lt; el_type &gt;</a></td></tr>
<tr class="memitem:aac6d12fd87c19ad7d39f0fbdf7e0aa01 inherit pub_types_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac6d12fd87c19ad7d39f0fbdf7e0aa01"></a>
typedef vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>idx_vector_type</b></td></tr>
<tr class="separator:aac6d12fd87c19ad7d39f0fbdf7e0aa01 inherit pub_types_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac442ebc44706f184c7ce4ee7e1fdd6d inherit pub_types_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac442ebc44706f184c7ce4ee7e1fdd6d"></a>
typedef vector&lt; el_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>elt_vector_type</b></td></tr>
<tr class="separator:aac442ebc44706f184c7ce4ee7e1fdd6d inherit pub_types_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acdaad0931ff27d7bfc361d3033713914"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdaad0931ff27d7bfc361d3033713914"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#acdaad0931ff27d7bfc361d3033713914">lilc_matrix</a> (int <a class="el" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>=0, int <a class="el" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>=0)</td></tr>
<tr class="memdesc:acdaad0931ff27d7bfc361d3033713914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a column oriented list-of-lists (LIL) matrix. Space for both the values list and the indices list of the matrix is allocated here. <br /></td></tr>
<tr class="separator:acdaad0931ff27d7bfc361d3033713914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e59d373ec514c8cb264da653d36f753"><td class="memItemLeft" align="right" valign="top">virtual el_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#a0e59d373ec514c8cb264da653d36f753">coeff</a> (const int &amp;i, const int &amp;j, int offset=0) const </td></tr>
<tr class="memdesc:a0e59d373ec514c8cb264da653d36f753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the (i,j)th coefficient of the matrix.  <a href="#a0e59d373ec514c8cb264da653d36f753">More...</a><br /></td></tr>
<tr class="separator:a0e59d373ec514c8cb264da653d36f753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327c165f0c90cd362dd14fc6421ebadd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#a327c165f0c90cd362dd14fc6421ebadd">coeffRef</a> (const int &amp;i, const int &amp;j, std::pair&lt; idx_it, elt_it &gt; &amp;its)</td></tr>
<tr class="memdesc:a327c165f0c90cd362dd14fc6421ebadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index/value pointers to (i,j)th coefficient of the matrix.  <a href="#a327c165f0c90cd362dd14fc6421ebadd">More...</a><br /></td></tr>
<tr class="separator:a327c165f0c90cd362dd14fc6421ebadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca815e0ac073abb1e6ef888b09f9e795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#aca815e0ac073abb1e6ef888b09f9e795">resize</a> (int <a class="el" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>, int <a class="el" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>)</td></tr>
<tr class="memdesc:aca815e0ac073abb1e6ef888b09f9e795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix. For use in preallocating space before factorization begins.  <a href="#aca815e0ac073abb1e6ef888b09f9e795">More...</a><br /></td></tr>
<tr class="separator:aca815e0ac073abb1e6ef888b09f9e795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46161695c5bfb0f43a7dedb9b9146fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#a46161695c5bfb0f43a7dedb9b9146fef">find_root</a> (int &amp;s)</td></tr>
<tr class="memdesc:a46161695c5bfb0f43a7dedb9b9146fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pseudo-peripheral root of A. This is essentially many chained breadth-first searchs across the graph of A (where A is viewed as an adjacency matrix).  <a href="#a46161695c5bfb0f43a7dedb9b9146fef">More...</a><br /></td></tr>
<tr class="separator:a46161695c5bfb0f43a7dedb9b9146fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad343cd9b2f435f40a9866de050f63ce5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#ad343cd9b2f435f40a9866de050f63ce5">find_level_set</a> (vector&lt; int &gt; &amp;lvl_set, vector&lt; bool &gt; &amp;visited)</td></tr>
<tr class="memdesc:ad343cd9b2f435f40a9866de050f63ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next level set given the current level set of A. This is essentially all neighbours of the currently enqueued nodes in breath-first search.  <a href="#ad343cd9b2f435f40a9866de050f63ce5">More...</a><br /></td></tr>
<tr class="separator:ad343cd9b2f435f40a9866de050f63ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34914d2b48a5bf14e7ef22e89d2f2e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#ab34914d2b48a5bf14e7ef22e89d2f2e7">sym_rcm</a> (vector&lt; int &gt; &amp;perm)</td></tr>
<tr class="memdesc:ab34914d2b48a5bf14e7ef22e89d2f2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Reverse Cuthill-McKee ordering of the matrix A (stored in perm).  <a href="#ab34914d2b48a5bf14e7ef22e89d2f2e7">More...</a><br /></td></tr>
<tr class="separator:ab34914d2b48a5bf14e7ef22e89d2f2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add59bf538bd6b36c7d42ec879bad4da8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#add59bf538bd6b36c7d42ec879bad4da8">sym_amd</a> (vector&lt; int &gt; &amp;perm)</td></tr>
<tr class="memdesc:add59bf538bd6b36c7d42ec879bad4da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Approximate Minimum Degree ordering of the matrix A (stored in perm).  <a href="#add59bf538bd6b36c7d42ec879bad4da8">More...</a><br /></td></tr>
<tr class="separator:add59bf538bd6b36c7d42ec879bad4da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72f55f6880cef04205eb3df7018bce9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#af72f55f6880cef04205eb3df7018bce9">sym_perm</a> (vector&lt; int &gt; &amp;perm)</td></tr>
<tr class="memdesc:af72f55f6880cef04205eb3df7018bce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a permutation vector perm, A is permuted to P'AP, where P is the permutation matrix associated with perm.  <a href="#af72f55f6880cef04205eb3df7018bce9">More...</a><br /></td></tr>
<tr class="separator:af72f55f6880cef04205eb3df7018bce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fc8dcc40799dfde0decaaf8bd74b51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#a37fc8dcc40799dfde0decaaf8bd74b51">sym_equil</a> ()</td></tr>
<tr class="memdesc:a37fc8dcc40799dfde0decaaf8bd74b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">The symmetric matrix A is equilibrated and the symmetric equilibrated matrix SAS is stored in A, where S is a diagonal scaling matrix.  <a href="#a37fc8dcc40799dfde0decaaf8bd74b51">More...</a><br /></td></tr>
<tr class="separator:a37fc8dcc40799dfde0decaaf8bd74b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5886c7d465252b8d8981d484b51ab58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#ab5886c7d465252b8d8981d484b51ab58">ildl</a> (<a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;L, <a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt; &amp;D, idx_vector_type &amp;perm, const double &amp;fill_factor, const double &amp;tol, const double &amp;pp_tol, int piv_type=pivot_type::BKP)</td></tr>
<tr class="memdesc:ab5886c7d465252b8d8981d484b51ab58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an LDL' factorization of this matrix.  <a href="#ab5886c7d465252b8d8981d484b51ab58">More...</a><br /></td></tr>
<tr class="separator:ab5886c7d465252b8d8981d484b51ab58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd39d93fc0df6618f7a59a05661c63e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#aefd39d93fc0df6618f7a59a05661c63e">ildl_inplace</a> (<a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt; &amp;D, idx_vector_type &amp;perm, const double &amp;fill_factor, const double &amp;tol, const double &amp;pp_tol, int piv_type=pivot_type::BKP)</td></tr>
<tr class="memdesc:aefd39d93fc0df6618f7a59a05661c63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an <em>inplace</em> LDL' factorization of this matrix.  <a href="#aefd39d93fc0df6618f7a59a05661c63e">More...</a><br /></td></tr>
<tr class="separator:aefd39d93fc0df6618f7a59a05661c63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0dbfcd1cda4ab3bc067b16f17f7f2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#a9e0dbfcd1cda4ab3bc067b16f17f7f2f">backsolve</a> (const elt_vector_type &amp;b, elt_vector_type &amp;x)</td></tr>
<tr class="memdesc:a9e0dbfcd1cda4ab3bc067b16f17f7f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a back solve of this matrix, assuming that it is lower triangular (stored column major).  <a href="#a9e0dbfcd1cda4ab3bc067b16f17f7f2f">More...</a><br /></td></tr>
<tr class="separator:a9e0dbfcd1cda4ab3bc067b16f17f7f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd669063a9594f4d33b01f24bf693edd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#afd669063a9594f4d33b01f24bf693edd">forwardsolve</a> (const elt_vector_type &amp;b, elt_vector_type &amp;x)</td></tr>
<tr class="memdesc:afd669063a9594f4d33b01f24bf693edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a forward solve of this matrix, assuming that it is upper triangular (stored row major).  <a href="#afd669063a9594f4d33b01f24bf693edd">More...</a><br /></td></tr>
<tr class="separator:afd669063a9594f4d33b01f24bf693edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00362a639b1e8ec341014c39afaf5e5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#a00362a639b1e8ec341014c39afaf5e5a">multiply</a> (const elt_vector_type &amp;x, elt_vector_type &amp;y, bool full_mult=true)</td></tr>
<tr class="memdesc:a00362a639b1e8ec341014c39afaf5e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a matrix-vector product with this matrix.  <a href="#a00362a639b1e8ec341014c39afaf5e5a">More...</a><br /></td></tr>
<tr class="separator:a00362a639b1e8ec341014c39afaf5e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb81dfe0808df725cf91f0d7639dcd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#a0bb81dfe0808df725cf91f0d7639dcd0">pivot</a> (<a class="el" href="classswap__struct.html">swap_struct</a>&lt; el_type &gt; &amp;s, vector&lt; bool &gt; &amp;in_set, <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;L, const int &amp;k, const int &amp;r)</td></tr>
<tr class="memdesc:a0bb81dfe0808df725cf91f0d7639dcd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a symmetric permutation between row/col k &amp; r of A.  <a href="#a0bb81dfe0808df725cf91f0d7639dcd0">More...</a><br /></td></tr>
<tr class="separator:a0bb81dfe0808df725cf91f0d7639dcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecb203a3a6ebc85bf0c3a603e6b0fa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#aaecb203a3a6ebc85bf0c3a603e6b0fa2">pivotA</a> (<a class="el" href="classswap__struct.html">swap_struct</a>&lt; el_type &gt; &amp;s, vector&lt; bool &gt; &amp;in_set, const int &amp;k, const int &amp;r)</td></tr>
<tr class="memdesc:aaecb203a3a6ebc85bf0c3a603e6b0fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inplace version of the function above.  <a href="#aaecb203a3a6ebc85bf0c3a603e6b0fa2">More...</a><br /></td></tr>
<tr class="separator:aaecb203a3a6ebc85bf0c3a603e6b0fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d3045545357a8f33955a87dc55f3aa"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:aa1d3045545357a8f33955a87dc55f3aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#aa1d3045545357a8f33955a87dc55f3aa">ensure_invariant</a> (const int &amp;j, const int &amp;k, Container &amp;con, bool update_list=false)</td></tr>
<tr class="memdesc:aa1d3045545357a8f33955a87dc55f3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures two the invariants observed by A.first and A.list are held.  <a href="#aa1d3045545357a8f33955a87dc55f3aa">More...</a><br /></td></tr>
<tr class="separator:aa1d3045545357a8f33955a87dc55f3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177dde39764c88fe4e82b050a5e60303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#a177dde39764c88fe4e82b050a5e60303">advance_first</a> (const int &amp;k)</td></tr>
<tr class="memdesc:a177dde39764c88fe4e82b050a5e60303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates A.first for iteration k.  <a href="#a177dde39764c88fe4e82b050a5e60303">More...</a><br /></td></tr>
<tr class="separator:a177dde39764c88fe4e82b050a5e60303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ee09328b84657630f52631ea8e5eb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#ab9ee09328b84657630f52631ea8e5eb1">advance_list</a> (const int &amp;k)</td></tr>
<tr class="memdesc:ab9ee09328b84657630f52631ea8e5eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates A.list for iteration k.  <a href="#ab9ee09328b84657630f52631ea8e5eb1">More...</a><br /></td></tr>
<tr class="separator:ab9ee09328b84657630f52631ea8e5eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c5a4a0ec9a49d43be087b6d67f4df2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#a60c5a4a0ec9a49d43be087b6d67f4df2">to_string</a> () const </td></tr>
<tr class="memdesc:a60c5a4a0ec9a49d43be087b6d67f4df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of A, with each column and its corresponding indices &amp; non-zero values printed.  <a href="#a60c5a4a0ec9a49d43be087b6d67f4df2">More...</a><br /></td></tr>
<tr class="separator:a60c5a4a0ec9a49d43be087b6d67f4df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5613e9a57231a6991dcf99d6d7b37a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#aea5613e9a57231a6991dcf99d6d7b37a">load</a> (std::string filename)</td></tr>
<tr class="memdesc:aea5613e9a57231a6991dcf99d6d7b37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a matrix in matrix market format.  <a href="#aea5613e9a57231a6991dcf99d6d7b37a">More...</a><br /></td></tr>
<tr class="separator:aea5613e9a57231a6991dcf99d6d7b37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0161d36019e1abac41b6119b8fa288"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#a2b0161d36019e1abac41b6119b8fa288">save</a> (std::string filename, bool sym=false)</td></tr>
<tr class="memdesc:a2b0161d36019e1abac41b6119b8fa288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a matrix in matrix market format.  <a href="#a2b0161d36019e1abac41b6119b8fa288">More...</a><br /></td></tr>
<tr class="separator:a2b0161d36019e1abac41b6119b8fa288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classlil__sparse__matrix"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classlil__sparse__matrix')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix&lt; el_type &gt;</a></td></tr>
<tr class="memitem:a74dff1c9df79556341d714d4530ffe38 inherit pub_methods_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74dff1c9df79556341d714d4530ffe38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#a74dff1c9df79556341d714d4530ffe38">lil_sparse_matrix</a> (int <a class="el" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a>, int <a class="el" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a>)</td></tr>
<tr class="memdesc:a74dff1c9df79556341d714d4530ffe38 inherit pub_methods_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for an abstract matrix. This constructor will be extended by base classes depending on the representation of the matrix (LIL-C or LIL-R). <br /></td></tr>
<tr class="separator:a74dff1c9df79556341d714d4530ffe38 inherit pub_methods_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e9ea5f7c8a9fca9029a91b39c592e0 inherit pub_methods_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#a29e9ea5f7c8a9fca9029a91b39c592e0">n_rows</a> () const </td></tr>
<tr class="separator:a29e9ea5f7c8a9fca9029a91b39c592e0 inherit pub_methods_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88631204bcf7c9a223fb082a7d0cd3d inherit pub_methods_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#ac88631204bcf7c9a223fb082a7d0cd3d">n_cols</a> () const </td></tr>
<tr class="separator:ac88631204bcf7c9a223fb082a7d0cd3d inherit pub_methods_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bc09d3b6716e57134eed0aeba49199 inherit pub_methods_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#a40bc09d3b6716e57134eed0aeba49199">nnz</a> () const </td></tr>
<tr class="separator:a40bc09d3b6716e57134eed0aeba49199 inherit pub_methods_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd4e61eeb73f709d0900cc064d8986d inherit pub_methods_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#aebd4e61eeb73f709d0900cc064d8986d">~lil_sparse_matrix</a> ()</td></tr>
<tr class="separator:aebd4e61eeb73f709d0900cc064d8986d inherit pub_methods_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad942a0e5503a2b4327a12287432fca81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad942a0e5503a2b4327a12287432fca81"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#ad942a0e5503a2b4327a12287432fca81">list</a></td></tr>
<tr class="memdesc:ad942a0e5503a2b4327a12287432fca81"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of linked lists that gives the non-zero elements in each row of A. Since at any time we may swap between two rows, we require linked lists for each row of A. <br /></td></tr>
<tr class="separator:ad942a0e5503a2b4327a12287432fca81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca57e0c3866ed0cf1f17f6253666ebb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ca57e0c3866ed0cf1f17f6253666ebb"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#a2ca57e0c3866ed0cf1f17f6253666ebb">row_first</a></td></tr>
<tr class="memdesc:a2ca57e0c3866ed0cf1f17f6253666ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">On iteration k, first[i] gives the number of non-zero elements on row i of A before A(i, k). <br /></td></tr>
<tr class="separator:a2ca57e0c3866ed0cf1f17f6253666ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c12de6fccae4ac5a885e8aa60788e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36c12de6fccae4ac5a885e8aa60788e9"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#a36c12de6fccae4ac5a885e8aa60788e9">col_first</a></td></tr>
<tr class="memdesc:a36c12de6fccae4ac5a885e8aa60788e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">On iteration k, first[i] gives the number of non-zero elements on col i of A before A(i, k). <br /></td></tr>
<tr class="separator:a36c12de6fccae4ac5a885e8aa60788e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4659265addfeab376ffaa8f54ed596"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc4659265addfeab376ffaa8f54ed596"></a>
<a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="singletonlilc__matrix.html#afc4659265addfeab376ffaa8f54ed596">S</a></td></tr>
<tr class="memdesc:afc4659265addfeab376ffaa8f54ed596"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagonal scaling matrix S such that SAS will be equilibriated in the max-norm (i.e. every row/column has norm 1). S is constructed after running the <a class="el" href="singletonlilc__matrix.html#a37fc8dcc40799dfde0decaaf8bd74b51" title="The symmetric matrix A is equilibrated and the symmetric equilibrated matrix SAS is stored in A...">sym_equil()</a> function, after which SAS will be stored in place of A. <br /></td></tr>
<tr class="separator:afc4659265addfeab376ffaa8f54ed596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classlil__sparse__matrix"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classlil__sparse__matrix')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classlil__sparse__matrix.html">lil_sparse_matrix&lt; el_type &gt;</a></td></tr>
<tr class="memitem:a6eac075dab519f837ae660c9ef933eb9 inherit pub_attribs_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eac075dab519f837ae660c9ef933eb9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#a6eac075dab519f837ae660c9ef933eb9">m_n_rows</a></td></tr>
<tr class="memdesc:a6eac075dab519f837ae660c9ef933eb9 inherit pub_attribs_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows in the matrix. <br /></td></tr>
<tr class="separator:a6eac075dab519f837ae660c9ef933eb9 inherit pub_attribs_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab335a46ece471fd0edf52540e24225a inherit pub_attribs_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab335a46ece471fd0edf52540e24225a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#aab335a46ece471fd0edf52540e24225a">m_n_cols</a></td></tr>
<tr class="memdesc:aab335a46ece471fd0edf52540e24225a inherit pub_attribs_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of cols in the matrix. <br /></td></tr>
<tr class="separator:aab335a46ece471fd0edf52540e24225a inherit pub_attribs_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc8477f4f3893490bbf0b196438fab8 inherit pub_attribs_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdc8477f4f3893490bbf0b196438fab8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#acdc8477f4f3893490bbf0b196438fab8">nnz_count</a></td></tr>
<tr class="memdesc:acdc8477f4f3893490bbf0b196438fab8 inherit pub_attribs_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nonzeros in the matrix. <br /></td></tr>
<tr class="separator:acdc8477f4f3893490bbf0b196438fab8 inherit pub_attribs_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af764d0312eb9f7939ab144b12972bf56 inherit pub_attribs_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af764d0312eb9f7939ab144b12972bf56"></a>
el_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#af764d0312eb9f7939ab144b12972bf56">eps</a></td></tr>
<tr class="memdesc:af764d0312eb9f7939ab144b12972bf56 inherit pub_attribs_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">Machine epsilon for el_type. <br /></td></tr>
<tr class="separator:af764d0312eb9f7939ab144b12972bf56 inherit pub_attribs_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133b6db4ddc63626a8787abbb2564aa6 inherit pub_attribs_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a133b6db4ddc63626a8787abbb2564aa6"></a>
vector&lt; idx_vector_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#a133b6db4ddc63626a8787abbb2564aa6">m_idx</a></td></tr>
<tr class="memdesc:a133b6db4ddc63626a8787abbb2564aa6 inherit pub_attribs_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">The row/col indices. The way m_idx is used depends on whether the matrix is in LIL-C or LIL-R. <br /></td></tr>
<tr class="separator:a133b6db4ddc63626a8787abbb2564aa6 inherit pub_attribs_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2abac5da68172e1e3e21376247643de inherit pub_attribs_classlil__sparse__matrix"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2abac5da68172e1e3e21376247643de"></a>
vector&lt; elt_vector_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlil__sparse__matrix.html#ac2abac5da68172e1e3e21376247643de">m_x</a></td></tr>
<tr class="memdesc:ac2abac5da68172e1e3e21376247643de inherit pub_attribs_classlil__sparse__matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">The values of the nonzeros in the matrix. <br /></td></tr>
<tr class="separator:ac2abac5da68172e1e3e21376247643de inherit pub_attribs_classlil__sparse__matrix"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class el_type&gt;<br />
class lilc_matrix&lt; el_type &gt;</h3>

<p>A list-of-lists (LIL) matrix in column oriented format. </p>
<p>For convience, the matrix this class represents will be refered to as matrix A. In LIL-C format, each column of A (an n*n matrix) is stored as a separate vector. The nonzeros are stored in m_idx while the non-zeros are stored in m_x. Both m_x and m_idx are initialized to a list of n lists. m_idx and m_x are ordered dependent on each other, in that A(m_idx[k][j], k) = m_x[k][j]. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a177dde39764c88fe4e82b050a5e60303"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::advance_first </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates A.first for iteration k. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>current iteration index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9ee09328b84657630f52631ea8e5eb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::advance_list </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates A.list for iteration k. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>current iteration index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e0dbfcd1cda4ab3bc067b16f17f7f2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::backsolve </td>
          <td>(</td>
          <td class="paramtype">const elt_vector_type &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">elt_vector_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a back solve of this matrix, assuming that it is lower triangular (stored column major). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the right hand side. </td></tr>
    <tr><td class="paramname">x</td><td>a storage vector for the solution (must be same size as b). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e59d373ec514c8cb264da653d36f753"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual el_type <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::coeff </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the (i,j)th coefficient of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the row of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">j</td><td>the col of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">offset</td><td>an optional search offset for use in linear search (start at offset instead of 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (i,j)th element of the matrix. </dd></dl>

<p>Implements <a class="el" href="classlil__sparse__matrix.html#a03af482b9f3d8c8b522dd5e49a2500ee">lil_sparse_matrix&lt; el_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a327c165f0c90cd362dd14fc6421ebadd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::coeffRef </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; idx_it, elt_it &gt; &amp;&#160;</td>
          <td class="paramname"><em>its</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index/value pointers to (i,j)th coefficient of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the row of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">j</td><td>the col of the (i,j)th element (zero-indexed). </td></tr>
    <tr><td class="paramname">its</td><td>a pair of pointers, one for the index of the found element, and the other for the value of the element. If the element is not found, the pointers point to the end of column j.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if (i,j)th element is nonzero, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1d3045545357a8f33955a87dc55f3aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::ensure_invariant </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update_list</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures two the invariants observed by A.first and A.list are held. </p>
<dl class="section invariant"><dt>Invariant</dt><dd>If this matrix is a lower triangular factor of another matrix:<ol type="1">
<li>On iteration k, first[i] will give the number of non-zero elements on col i of A before A(k, i).</li>
<li>On iteration k, list[i][ first[i] ] will contain the first element below or on index k of column i of A.</li>
</ol>
</dd>
<dd>
If this matrix is the matrix to be factored:<ol type="1">
<li>On iteration k, first[i] will give the number of non-zero elements on row i of A before A(i, k).</li>
<li>On iteration k, list[i][ first[i] ] will contain the first element right of or on index k of row i of A.</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>the column of con. </td></tr>
    <tr><td class="paramname">k</td><td>the iteration number. </td></tr>
    <tr><td class="paramname">con</td><td>the container to be swapped. </td></tr>
    <tr><td class="paramname">update_list</td><td>boolean indicating whether list or m_x/m_idx should be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad343cd9b2f435f40a9866de050f63ce5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::find_level_set </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>lvl_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next level set given the current level set of A. This is essentially all neighbours of the currently enqueued nodes in breath-first search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lvl_set</td><td>the current level set (a list of nodes). </td></tr>
    <tr><td class="paramname">visited</td><td>all previously visited nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46161695c5bfb0f43a7dedb9b9146fef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::find_root </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pseudo-peripheral root of A. This is essentially many chained breadth-first searchs across the graph of A (where A is viewed as an adjacency matrix). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>contains the initial node to seed the algorithm. A pseudo-peripheral root of A is stored in s at the end of the algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd669063a9594f4d33b01f24bf693edd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::forwardsolve </td>
          <td>(</td>
          <td class="paramtype">const elt_vector_type &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">elt_vector_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a forward solve of this matrix, assuming that it is upper triangular (stored row major). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the right hand side. </td></tr>
    <tr><td class="paramname">x</td><td>a storage vector for the solution (must be same size as b). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5886c7d465252b8d8981d484b51ab58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::ildl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">idx_vector_type &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>fill_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>pp_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>piv_type</em> = <code>pivot_type::BKP</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an LDL' factorization of this matrix. </p>
<p>The pivoted matrix P'AP will be stored in place of A. In addition, the L and D factors of P'AP will be stored in L and D (so that P'AP = LDL'). The factorization is performed in crout order and follows the algorithm outlined in "Crout versions of the ILU factorization with pivoting for sparse symmetric matrices" by Li and Saad (2005).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>the L factor of this matrix. </td></tr>
    <tr><td class="paramname">D</td><td>the D factor of this matrix. </td></tr>
    <tr><td class="paramname">perm</td><td>the current permutation of A. </td></tr>
    <tr><td class="paramname">fill_factor</td><td>a parameter to control memory usage. Each column is guaranteed to have fewer than fill_factor*(nnz(A)/n_col(A)) elements. </td></tr>
    <tr><td class="paramname">tol</td><td>a parameter to control agressiveness of dropping. In each column, elements less than tol*norm(column) are dropped. </td></tr>
    <tr><td class="paramname">pp_tol</td><td>a parameter to control aggresiveness of pivoting. Allowable ranges are [0,inf). If the parameter is &gt;= 1, Bunch-Kaufman pivoting will be done in full. If the parameter is 0, partial pivoting will be turned off and the first non-zero pivot under the diagonal will be used. Choices close to 0 increase locality in pivoting (pivots closer to the diagonal are used) while choices closer to 1 increase the stability of pivoting. Useful for situations where you care more about preserving the structure of the matrix rather than bounding the size of its elements. </td></tr>
    <tr><td class="paramname"><a class="el" href="structlilc__matrix_1_1pivot__type.html">pivot_type</a></td><td>chooses the type of pivoting procedure used: threshold Bunch-Kaufman, or rook pivoting. If rook pivoting is chosen, pp_tol is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefd39d93fc0df6618f7a59a05661c63e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::ildl_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classblock__diag__matrix.html">block_diag_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">idx_vector_type &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>fill_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>pp_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>piv_type</em> = <code>pivot_type::BKP</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an <em>inplace</em> LDL' factorization of this matrix. </p>
<p>The pivoted matrix P'AP will be stored in place of A. In addition, the L and D factors of P'AP will be stored in L and D (so that P'AP = LDL'). The factorization is performed in crout order and follows the algorithm outlined in "Crout versions of the ILU factorization with pivoting for sparse symmetric matrices" by Li and Saad (2005).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>the D factor of this matrix. </td></tr>
    <tr><td class="paramname">perm</td><td>the current permutation of A. </td></tr>
    <tr><td class="paramname">fill_factor</td><td>a parameter to control memory usage. Each column is guaranteed to have fewer than fill_factor*(nnz(A)/n_col(A)) elements. </td></tr>
    <tr><td class="paramname">tol</td><td>a parameter to control agressiveness of dropping. In each column, elements less than tol*norm(column) are dropped. </td></tr>
    <tr><td class="paramname">pp_tol</td><td>a parameter to control aggresiveness of pivoting. Allowable ranges are [0,inf). If the parameter is &gt;= 1, Bunch-Kaufman pivoting will be done in full. If the parameter is 0, partial pivoting will be turned off and the first non-zero pivot under the diagonal will be used. Choices close to 0 increase locality in pivoting (pivots closer to the diagonal are used) while choices closer to 1 increase the stability of pivoting. Useful for situations where you care more about preserving the structure of the matrix rather than bounding the size of its elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea5613e9a57231a6991dcf99d6d7b37a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::load </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a matrix in matrix market format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the matrix to be loaded. Must be in matrix market format (.mtx). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00362a639b1e8ec341014c39afaf5e5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::multiply </td>
          <td>(</td>
          <td class="paramtype">const elt_vector_type &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">elt_vector_type &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_mult</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a matrix-vector product with this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the vector to be multiplied. </td></tr>
    <tr><td class="paramname">y</td><td>a storage vector for the result (must be same size as x). </td></tr>
    <tr><td class="paramname">full_mult</td><td>if true, we assume that only half the matrix is stored and do do operations per element of the matrix to account for the unstored other half. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bb81dfe0808df725cf91f0d7639dcd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::pivot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classswap__struct.html">swap_struct</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a symmetric permutation between row/col k &amp; r of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a struct containing temporary variables needed during pivoting. </td></tr>
    <tr><td class="paramname">in_set</td><td>a bitset needed for unordered unions during pivoting. </td></tr>
    <tr><td class="paramname">L</td><td>the lower triangular factor of A. </td></tr>
    <tr><td class="paramname">k</td><td>index of row/col k. </td></tr>
    <tr><td class="paramname">r</td><td>index of row/col r.</td></tr>
  </table>
  </dd>
</dl>
<p>There are four parts to this pivoting algorithm. For A, due to storing only the lower half, there are three steps to performing a symmetric permutation:</p><ol type="1">
<li>A(k, 1:k) must be swapped with A(r, 1:k) (row-row swap).</li>
<li>A(k:r, k) must be swapped with A(r, k:r) (row-column swap).</li>
<li>A(k:r, k) must be swapped with A(k:r, r) (column-column swap). The steps above are implemented in the pivotA function.</li>
</ol>
<p>For L, since column k and r are not yet formed, there is only one step (a row permutation):</p><ol type="1">
<li>L(k, 1:k) must be swapped with L(r, 1:k) (row-row swap). </li>
</ol>

</div>
</div>
<a class="anchor" id="aaecb203a3a6ebc85bf0c3a603e6b0fa2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::pivotA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classswap__struct.html">swap_struct</a>&lt; el_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The inplace version of the function above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a struct containing temporary variables needed during pivoting. </td></tr>
    <tr><td class="paramname">in_set</td><td>a bitset needed for unordered unions during pivoting. </td></tr>
    <tr><td class="paramname">k</td><td>index of row/col k. </td></tr>
    <tr><td class="paramname">r</td><td>index of row/col r.</td></tr>
  </table>
  </dd>
</dl>
<p>There are three parts to this pivoting algorithm. For A, due to storing only the lower half, there are three steps to performing a symmetric permutation:</p><ol type="1">
<li>A(k, 1:k) must be swapped with A(r, 1:k) (row-row swap).</li>
<li>A(k:r, k) must be swapped with A(r, k:r) (row-column swap).</li>
<li>A(k:r, k) must be swapped with A(k:r, r) (column-column swap). </li>
</ol>

</div>
</div>
<a class="anchor" id="aca815e0ac073abb1e6ef888b09f9e795"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the matrix. For use in preallocating space before factorization begins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_rows</td><td>the number of rows in the resized matrix. </td></tr>
    <tr><td class="paramname">n_cols</td><td>the number of cols in the resized matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b0161d36019e1abac41b6119b8fa288"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::save </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sym</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a matrix in matrix market format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the matrix to be saved. All matrices saved are in matrix market format (.mtx). </td></tr>
    <tr><td class="paramname">sym</td><td>flags whether the matrix is symmetric or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add59bf538bd6b36c7d42ec879bad4da8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::sym_amd </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a Approximate Minimum Degree ordering of the matrix A (stored in perm). </p>
<p>A detailed description of this function as well as all its subfunctions can be found in "An Approximate Minimum Dgree Algorithm" by Davis, Amestoy, and Duff (1981). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>An empty permutation vector (filled on function completion). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37fc8dcc40799dfde0decaaf8bd74b51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::sym_equil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The symmetric matrix A is equilibrated and the symmetric equilibrated matrix SAS is stored in A, where S is a diagonal scaling matrix. </p>
<p>This algorithm is based on the one outlined in "Equilibration of Symmetric Matrices in the Max-Norm" by Bunch (1971). </p>

</div>
</div>
<a class="anchor" id="af72f55f6880cef04205eb3df7018bce9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::sym_perm </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a permutation vector perm, A is permuted to P'AP, where P is the permutation matrix associated with perm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>the permutation vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab34914d2b48a5bf14e7ef22e89d2f2e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::sym_rcm </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a Reverse Cuthill-McKee ordering of the matrix A (stored in perm). </p>
<p>A detailed description of this function as well as all its subfunctions can be found in "Computer Solution of Large Sparse Positive Definite Systems" by George and Liu (1981). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>An empty permutation vector (filled on function completion). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60c5a4a0ec9a49d43be087b6d67f4df2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class el_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="singletonlilc__matrix.html">lilc_matrix</a>&lt; el_type &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string representation of A, with each column and its corresponding indices &amp; non-zero values printed. </p>
<dl class="section return"><dt>Returns</dt><dd>A string representation of this matrix. </dd></dl>

<p>Implements <a class="el" href="classlil__sparse__matrix.html#a5c2c43867660473176de5c73ebdac7be">lil_sparse_matrix&lt; el_type &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/<a class="el" href="lilc__matrix_8h_source.html">lilc_matrix.h</a></li>
<li>source/<a class="el" href="lilc__matrix__declarations_8h_source.html">lilc_matrix_declarations.h</a></li>
<li>source/<a class="el" href="lilc__matrix__find__level__set_8h_source.html">lilc_matrix_find_level_set.h</a></li>
<li>source/<a class="el" href="lilc__matrix__find__root_8h_source.html">lilc_matrix_find_root.h</a></li>
<li>source/<a class="el" href="lilc__matrix__ildl_8h_source.html">lilc_matrix_ildl.h</a></li>
<li>source/<a class="el" href="lilc__matrix__ildl__inplace_8h_source.html">lilc_matrix_ildl_inplace.h</a></li>
<li>source/<a class="el" href="lilc__matrix__load_8h_source.html">lilc_matrix_load.h</a></li>
<li>source/<a class="el" href="lilc__matrix__pivot_8h_source.html">lilc_matrix_pivot.h</a></li>
<li>source/<a class="el" href="lilc__matrix__save_8h_source.html">lilc_matrix_save.h</a></li>
<li>source/<a class="el" href="lilc__matrix__sym__amd_8h_source.html">lilc_matrix_sym_amd.h</a></li>
<li>source/<a class="el" href="lilc__matrix__sym__equil_8h_source.html">lilc_matrix_sym_equil.h</a></li>
<li>source/<a class="el" href="lilc__matrix__sym__perm_8h_source.html">lilc_matrix_sym_perm.h</a></li>
<li>source/<a class="el" href="lilc__matrix__sym__rcm_8h_source.html">lilc_matrix_sym_rcm.h</a></li>
<li>source/<a class="el" href="lilc__matrix__to__string_8h_source.html">lilc_matrix_to_string.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 17 2016 01:34:23 for sym-ildl by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
